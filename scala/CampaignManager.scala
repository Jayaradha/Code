package radius

import org.apache.spark.SparkConf
import org.apache.spark.SparkContext

/**
  * Created by Jayaradha Natarajan on 7/31/16.
  *
  *
  * ## The Assignment
  *
  * The primary purpose of the assignment is to produce a simple data process from user files.
  * The main goal is to define a new Phone marketing campaign for top 1000 users in order to upsell them with a new compelling product.
  *
  *
  * ### The Data
  *
  * The data is fictitious and has been generated by a program but is representative of something that could have to be done in real life.
  * We have created the following files:

  * The 'transactions.txt' file contains information about transactions. The structure of the file is the following:
  * Customer ID, transaction amount, transaction date

  * The 'users.txt' file contains information about users. The structure of the files is the following:
  * Customer ID, Customer full name, email list, phone list

  * The 'donotcall.txt' file contains phone numbers that should not be used in the campaign
  *
  *
  * ### The Analysis
  *
  * The selection of the top 1000 users should include the following steps:
  *
  * Parsing of the files
  * We wish to contact users using phone numbers that are not in the do not call list.
  * As this is a phone campaign, there should be at least one phone number per user in the output.
  * Selecting the top users based on highest transaction amount for year 2015
  *
  * Save the campaign in a file using the following structure:
  *
  * Customer ID, Customer name, phone list that can be used to contact the user, total transaction amount
  */

object CampaignManager {
    /**
      *
      * The structure of "users.txt" is as follows:
      *
      * @param customerId - Customer ID
      * @param name - Customer full name
      * @param email - email list
      * @param phone - phone list
      */
    case class User(customerId: String, name: String, email: String, phone: String)

    /**
      * The Structure of "transactions.txt" is as follows:
      *
      * @param customerId -  Customer ID
      * @param amount - transaction amount
      * @param date - transaction date
      */
    case class Transaction(customerId: String, amount: Double, date: String)

    /** Phone list is loaded in a Set and every Phone number is compared with the List of phone numbers from the Phone List.
      *
      * @param phone - Phone Number from Transaction Data
      * @param phoneList - Phone Numbers from DoNotCall List
      * @return - Returns only allowed phone numbers.
      */
    def getAllowedPhoneNumbers(phone: String, phoneList: Set[String]): String =
    {
        var allowedPhoneNumbers: String = ""

        val phoneArray = phone.split(",")
        for (`phone` <- phoneArray) {
            if (!phoneList.contains(phone))
            {
                allowedPhoneNumbers = allowedPhoneNumbers + phone;
            }
        }

        if (allowedPhoneNumbers == "")
            allowedPhoneNumbers = "NaN"

        return allowedPhoneNumbers
    }

    def main(args: Array[String]): Unit = {
        println("\n main method")

        val sparkConf = new SparkConf().setAppName("mem").setMaster("local[1]") //remote
        implicit val sc = new SparkContext(sparkConf)

        try {
            /**
              * Load Users from "users.txt"
              * The phone number columns contains null and fill null with NaN
              * Eliminate Null rows by filtering.
              */
            val userLines = sc.textFile("Resources/users.txt")
            val usersRDD = userLines
                .map(_.split(";"))
                .map(row => (row(0), (User(row(0), row(1), row(2), if (row.length > 3) row(3) else "NaN"))))
                .filter(_._2.phone != "NaN")

            /**
              * Load List of not allowed phone numbers from "donotcall.txt"
              * Load "donotcalllist.txt" and populate in RDD
              */
            val doNotCallLines = sc.textFile("Resources/donotcall.txt")
            val doNotCallLinesRDD = doNotCallLines.map(phone => phone);
            val doNotCallList = doNotCallLinesRDD.collect.toSet

            /**
              * Load transansactions from "transactions.txt"
              * Load Transactions as paired RDD
              * Filter transactions that happened during year 2015
              * Sum the transaction amount of a user based on year
              */
            val transactionLines = sc.textFile("Resources/transactions.txt")
            val transactionRDD = transactionLines
                .map(_.split(";"))
                .map(row => (row(0), Transaction(row(0), row(1).substring(1).toDouble, row(2))))
                .filter(_._2.date.contains("2015"))
                .reduceByKey((x, y) => Transaction(x.customerId, x.amount + y.amount, x.date))

            /**
              * Join User and transactions based on customer ID
              * Filter Customer ID, Customer name, phone list
              * Compare the values in DoNot call list and eliminate
              */
            val userTransactionRDD = usersRDD.join(transactionRDD)
                .sortBy(_._2._2.amount,false)
                .map(row => (row._2._1.customerId,getAllowedPhoneNumbers(row._2._1.phone, doNotCallList), row._2._1.name, row._2._2.amount))
                .filter(_._2 != "NaN")

              //.saveAsTextFile()

            /**
              * Print final 1000 rows.
              */
            val finalRDD = sc.parallelize(userTransactionRDD.take(1000))
            finalRDD.saveAsTextFile("Result/PhoneCampaign")
        }
        catch {
            case e: Exception =>
                e.printStackTrace()
                sc.stop()
                System.exit(11)
        } finally {
            sc.stop()
        }
    }
}